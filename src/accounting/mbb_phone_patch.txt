--- integrated_bank_processor.py (original)
+++ integrated_bank_processor.py (modified)
@@ -919,6 +919,90 @@
         """
         Detect Vietnamese phone numbers in transaction description
         
+        Vietnamese phone number patterns with real-world variations:
+        - With leading zero: 0xxxxxxxxx
+        - Without leading zero: xxxxxxxxx (9-10 digits)
+        - With spaces: "0903 999 057", "0903-999-057", "0903.999.057" 
+        - Without spaces: "0903999057"
+        - International format: +84xxxxxxxxx, 84xxxxxxxxx
+        """
+        if not description:
+            return False
+        
+        # Remove common separators to normalize the number
+        normalized_desc = re.sub(r'[-.\ ]', '', description)
+        
+        # Vietnamese phone number patterns (comprehensive)
+        phone_patterns = [
+            # Standard format with leading zero (10 digits)
+            r'\b0[3|5|7|8|9]\d{8}\b',
+            
+            # Format with spaces, dashes, or dots
+            r'\b0[3|5|7|8|9][\s\-\.]*\d{3}[\s\-\.]*\d{3}[\s\-\.]*\d{3}\b',  # 0xxx xxx xxx
+            r'\b0[3|5|7|8|9][\s\-\.]*\d{4}[\s\-\.]*\d{4}\b',               # 0xxx xxxx xxxx
+            r'\b0[3|5|7|8|9][\s\-\.]*\d{2}[\s\-\.]*\d{3}[\s\-\.]*\d{3}\b',  # 0xx xxx xxx
+            
+            # Without leading zero (9-10 digits) - common in bank systems
+            r'\b[3|5|7|8|9]\d{8,9}\b',  # 9xxxxxxxx or 9xxxxxxxxx
+            
+            # International format
+            r'\b\+84[3|5|7|8|9]\d{8}\b',  # +84xxxxxxxxx
+            r'\b84[3|5|7|8|9]\d{8}\b',    # 84xxxxxxxxx
+        ]
+        
+        # First check original description (with spaces/separators)
+        for pattern in phone_patterns:
+            if re.search(pattern, description, re.IGNORECASE):
+                match = re.search(pattern, description, re.IGNORECASE)
+                self.logger.info(f"Detected Vietnamese phone number '{match.group()}' in description: {description}")
+                return True
+        
+        # Then check normalized description (without separators)
+        for pattern in phone_patterns:
+            if re.search(pattern, normalized_desc, re.IGNORECASE):
+                match = re.search(pattern, normalized_desc, re.IGNORECASE)
+                self.logger.info(f"Detected Vietnamese phone number '{match.group()}' in normalized description: {normalized_desc}")
+                return True
+        
+        return False
+
+    def _extract_phone_number_from_description(self, description: str) -> str:
+        """
+        Extract the actual phone number from description for logging/debugging
+        
+        Returns:
+            The phone number found, or empty string if none found
+        """
+        if not description:
+            return ""
+        
+        # Comprehensive phone number extraction
+        normalized_desc = re.sub(r'[-.\ ]', '', description)
+        
+        extraction_patterns = [
+            r'\b(0[3|5|7|8|9]\d{8})\b',
+            r'\b([3|5|7|8|9]\d{8,9})\b',
+            r'\b(\+84[3|5|7|8|9]\d{8})\b',
+            r'\b(84[3|5|7|8|9]\d{8})\b',
+        ]
+        
+        # Try original description first
+        for pattern in extraction_patterns:
+            match = re.search(pattern, description, re.IGNORECASE)
+            if match:
+                return match.group(1)
+        
+        # Try normalized description
+        for pattern in extraction_patterns:
+            match = re.search(pattern, normalized_desc, re.IGNORECASE)
+            if match:
+                return match.group(1)
+        
+        return ""
+
+    def _normalize_vietnamese_text(self, text: str) -> str:
+        """
+        Normalize Vietnamese text for pattern matching by removing diacritics
+        and converting to uppercase for consistent comparison.
+
+        Args:
+            text: Input Vietnamese text
+
+        Returns:
+            Normalized text with diacritics removed
+        """
+        if not text:
+            return text
+
+        # Convert to uppercase first
+        normalized = text.upper()
+
+        # Vietnamese diacritic removal mapping
+        vietnamese_chars = {
+            "Á": "A",
+            "À": "A",
+            "Ả": "A",
+            "Ã": "A",
+            "Ạ": "A",
+            "Ă": "A",
+            "Ắ": "A",
+            "Ằ": "A",
+            "Ẳ": "A",
+            "Ẵ": "A",
+            "Ặ": "A",
+            "Â": "A",
+            "Ấ": "A",
+            "Ầ": "A",
+            "Ẩ": "A",
+            "Ẫ": "A",
+            "Ậ": "A",
+            "É": "E",
+            "È": "E",
+            "Ẻ": "E",
+            "Ẽ": "E",
+            "Ẹ": "E",
+            "Ê": "E",
+            "Ế": "E",
+            "Ề": "E",
+            "Ể": "E",
+            "Ễ": "E",
+            "Ệ": "E",
+            "Í": "I",
+            "Ì": "I",
+            "Ỉ": "I",
+            "Ĩ": "I",
+            "Ị": "I",
+            "Ó": "O",
+            "Ò": "O",
+            "Ỏ": "O",
+            "Õ": "O",
+            "Ọ": "O",
+            "Ô": "O",
+            "Ố": "O",
+            "Ồ": "O",
+            "Ổ": "O",
+            "Ỗ": "O",
+            "Ộ": "O",
+            "Ơ": "O",
+            "Ớ": "O",
+            "Ờ": "O",
+            "Ở": "O",
+            "Ỡ": "O",
+            "Ợ": "O",
+            "Ú": "U",
+            "Ù": "U",
+            "Ủ": "U",
+            "Ũ": "U",
+            "Ụ": "U",
+            "Ư": "U",
+            "Ứ": "U",
+            "Ừ": "U",
+            "Ử": "U",
+            "Ữ": "U",
+            "Ự": "U",
+            "Ý": "Y",
+            "Ỳ": "Y",
+            "Ỷ": "Y",
+            "Ỹ": "Y",
+            "Ỵ": "Y",
+            "Đ": "D",
+        }
+
+        # Replace Vietnamese characters
+        for vn_char, en_char in vietnamese_chars.items():
+            normalized = normalized.replace(vn_char, en_char)
+
+        return normalized
+
+    def determine_special_accounts(
+        self, description: str, document_type: str
+    ) -> Tuple[Optional[str], Optional[str]]:
+        """
+        Check for special Vietnamese keywords and return appropriate account mappings.
+        This has the highest priority and should be called before other account determination logic.
+
+        Args:
+            description: Transaction description
+            document_type: Document type (BC for receipts, BN for payments)
+
+        Returns:
+            Tuple of (debit_account, credit_account) or (None, None) if no special keywords found
+        """
+        if not description:
+            return None, None
+
+        # Normalize the description for comparison
+        normalized_desc = self._normalize_vietnamese_text(description)
+
+        self.logger.debug(
+            f"Checking special accounts for: '{description}' -> '{normalized_desc}'"
+        )
+
+        # ENHANCED LOGIC: Special handling for "Phí cà thẻ" (Card fee)
+        normalized_phi_ca_the = self._normalize_vietnamese_text("Phí cà thẻ")
+        if normalized_phi_ca_the in normalized_desc:
+            self.logger.info(
+                f"Found 'Phí cà thẻ' in description: '{description}'"
+            )
+
+            # Use the same special account as interest payment (Thanh toan lai)
+            special_account = self.special_account_mappings.get(
+                "Thanh toan lai", "5154"
+            )
+
+            # Check that the account exists in our system
+            account_match = self.find_account_by_code(special_account)
+            if not account_match:
+                self.logger.warning(
+                    f"Special account {special_account} for 'Phí cà thẻ' not found in database. Falling back to normal logic."
+                )
+            else:
+                # Apply the same logic as interest payment based on document type
+                if document_type == "BC":  # Receipt/Credit transaction
+                    # For receipts: money comes into bank, special account is credited
+                    debit_account = self.default_bank_account
+                    credit_account = special_account
+
+                    # Store information about this being a special payment (same as interest payment)
+                    # This will cause process_transaction to use the bank info from filename
+                    self._current_transaction_is_interest_payment = True
+                    self.logger.info(
+                        "Set card fee transaction to use bank info from filename"
+                    )
+                    return debit_account, credit_account
+                else:  # BN - Payment/Debit transaction
+                    # For payments: money goes out of bank, special account is debited
+                    debit_account = special_account
+                    credit_account = self.default_bank_account
+
+                    # Store information about this being a special payment (same as interest payment)
+                    # This will cause process_transaction to use the bank info from filename
+                    self._current_transaction_is_interest_payment = True
+                    self.logger.info(
+                        "Set card fee transaction to use bank info from filename"
+                    )
+                    return debit_account, credit_account
+        
+@@ -2210,6 +2294,48 @@
+            # **PRIORITY 0 (HIGHEST): MBB Phone Number Detection for Online Transactions**
+            # Check if current bank is MBB and transaction description contains phone number
+            if (self.current_bank_name and 
+                self.current_bank_name.upper() == "MBB" and 
+                self._detect_phone_number_in_description(transaction.description)):
+                
+                # Extract the phone number for logging
+                phone_number = self._extract_phone_number_from_description(transaction.description)
+                
+                self.logger.info(
+                    f"MBB Online Transaction Detected: Bank={self.current_bank_name}, "
+                    f"Phone={phone_number}, Description={transaction.description}"
+                )
+                
+                # Apply MBB online transaction business logic
+                counterparty_info = {
+                    "code": "KLONLINE",
+                    "name": "KHÁCH LẺ KHÔNG LẤY HÓA ĐƠN (ONLINE)",
+                    "address": "4 Grand Canal Square, Grand Canal Harbour, Dublin 2, Ireland",
+                    "source": "mbb_phone_number_detection",
+                    "condition_applied": "mbb_online_phone_detected",
+                    "phone": phone_number,
+                    "tax_id": "",
+                }
+                
+                # Modify description for MBB phone transactions
+                # Extract PO number if available
+                po_match = re.search(r"PO\s*[:-]?\s*([A-Z0-9]+)", transaction.description, re.IGNORECASE)
+                po_number = po_match.group(1) if po_match else ""
+                
+                # Set description
+                if po_number:
+                    description = f"Thu tiền KH online thanh toán cho PO: {po_number}"
+                else:
+                    description = f"Thu tiền KH online thanh toán"
+                
+                self.logger.info(
+                    f"Applied MBB online counterparty logic: Code={counterparty_info['code']}, "
+                    f"Name={counterparty_info['name']}, Phone={phone_number}"
+                )
+            else:
+                # Only apply existing counterparty logic if MBB phone number detection didn't trigger
+                
+                # Priority 1: If extracted object is an account
+                if extracted_accounts:
